const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const { generateWallet, generateSecretKey, getStxAddress } = require('@stacks/wallet-sdk');
const {
  makeSTXTokenTransfer,
  broadcastTransaction,
  standardPrincipalCV,
  FungibleConditionCode,
  createAssetInfo,
  PostConditionMode,
  Pc,
  TransactionVersion
} = require('@stacks/transactions');
const { STACKS_MAINNET } = require('@stacks/network');
const TelegramBot = require('node-telegram-bot-api');
const crypto = require('crypto');
const User = require('./model/user.model')

require('dotenv').config();
const network = STACKS_MAINNET;
const PRIVATE_KEY_SECRET = process.env.PRIVATE_KEY_SECRET;
const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY;
const IV_LENGTH = 16;

const app = express();
const PORT = 5000;

app.use(express.json());
app.use(cors());

mongoose.connect(process.env.MONGO_URI)
  .then(() => console.log('MongoDB Connected'))
  .catch(err => console.error('MongoDB Connection Error:', err));

const bot = new TelegramBot(process.env.TELEGRAM_BOT_TOKEN, { polling: true });

function encryptPrivateKey(privateKey, pin) {
  const combinedKey = crypto.createHash('sha256').update(pin + PRIVATE_KEY_SECRET).digest();
  const iv = crypto.randomBytes(IV_LENGTH);
  const cipher = crypto.createCipheriv('aes-256-cbc', combinedKey, iv);
  let encrypted = cipher.update(privateKey);
  encrypted = Buffer.concat([encrypted, cipher.final()]);
  return iv.toString('hex') + ':' + encrypted.toString('hex');
}

function generateUniqueIndexes(max, count) {
  const indexes = new Set();
  while (indexes.size < count) {
    indexes.add(Math.floor(Math.random() * max));
  }
  return Array.from(indexes);
}

async function createWallet() {
  const secretKey = generateSecretKey(128);
  const wallet = await generateWallet({ secretKey, password: 'password' });
  const account = wallet.accounts[0];
  const address = getStxAddress({ account, transactionVersion: TransactionVersion });

  return {
    address,
    privateKey: account.stxPrivateKey,
    seedPhrase: secretKey
  };
}

bot.onText(/\/start/, async (msg) => {
  const chatId = msg.chat.id;
  const telegramId = String(msg.from.id);

  if (msg.chat.type !== 'private') {
    return bot.sendMessage(chatId, "ðŸš¨ *Please use the start command in a private message (DM) with the bot.*\n\nClick here to start: [Start DM](t.me/Beans_tipbot)", { parse_mode: "Markdown" });
  }

  try {
    const existingUser = await User.findOne({ telegramId });
    if (existingUser) {
      return bot.sendMessage(chatId, `ðŸš€ *You're already registered!*  
ðŸ”¹ *Wallet Address:* \`${existingUser.walletAddress}\`  

Use /help to see available commands.`, { parse_mode: "Markdown" });
    }

    const wallet = await createWallet();
    const words = wallet.seedPhrase.split(' ');
    const randomIndexes = generateUniqueIndexes(words.length, 3);
    const challengeWords = randomIndexes.map(i => words[i]);

    const sentMessage = await bot.sendMessage(chatId, `ðŸš¨ *IMPORTANT: Secure Your Seed Phrase!* ðŸš¨  

ðŸ”¹ *Wallet Address:* \`${wallet.address}\`  
ðŸ”¹ *Seed Phrase:* \`${wallet.seedPhrase}\`  

âš ï¸ *The bot does NOT store your seed phrase!*  
âœ… *Write it down and store it securely!*  

â³ *This message will be deleted in 15 minutes.*  

Have you saved your seed phrase?  
1ï¸âƒ£ Yes, I saved it  
2ï¸âƒ£ No, I need more time`, {
      parse_mode: "Markdown",
      reply_markup: {
        inline_keyboard: [
          [{ text: "âœ… Yes", callback_data: `seed_saved_${telegramId}` }],
          [{ text: "âŒ No", callback_data: `seed_not_saved_${telegramId}` }]
        ]
      }
    });

    setTimeout(() => {
      bot.deleteMessage(chatId, sentMessage.message_id).catch(() => { });
    }, 900000);

    bot.once("callback_query", async (callbackQuery) => {
      if (!callbackQuery.data.includes(`_${telegramId}`)) return;

      if (callbackQuery.data.startsWith("seed_saved")) {
        bot.deleteMessage(chatId, sentMessage.message_id).catch(() => { });

        bot.sendMessage(chatId, `ðŸ“Œ *Seed phrase verification:*  

Please enter the following words from your seed phrase:
- Word #${randomIndexes[0] + 1}
- Word #${randomIndexes[1] + 1}
- Word #${randomIndexes[2] + 1}

*(Reply in order, separated by spaces)*`, { parse_mode: "Markdown" });

        bot.once("message", async (response) => {
          const userResponse = response.text.trim().split(" ");
          if (
            userResponse.length === 3 &&
            userResponse[0] === challengeWords[0] &&
            userResponse[1] === challengeWords[1] &&
            userResponse[2] === challengeWords[2]
          ) {
            bot.sendMessage(chatId, "âœ… *Seed phrase verified!*");

            bot.sendMessage(chatId, "ðŸ” Please set a 5-digit PIN to secure your wallet.", {
              reply_markup: { force_reply: true }
            }).then((pinRequestMessage) => {
              bot.onReplyToMessage(chatId, pinRequestMessage.message_id, async (msg) => {
                const firstPin = msg.text.trim();
                await bot.deleteMessage(chatId, msg.message_id).catch(() => { });

                if (!/^\d{5}$/.test(firstPin)) {
                  return bot.sendMessage(chatId, "âš ï¸ Invalid PIN! Must be 5 digits. Try again:");
                }

                const confirmMessage = await bot.sendMessage(chatId, "ðŸ” Please re-enter your 5-digit PIN to confirm:", {
                  reply_markup: { force_reply: true }
                });

                bot.onReplyToMessage(chatId, confirmMessage.message_id, async (confirmMsg) => {
                  const confirmedPin = confirmMsg.text.trim();
                  await bot.deleteMessage(chatId, confirmMsg.message_id).catch(() => { });

                  if (firstPin !== confirmedPin) {
                    return bot.sendMessage(chatId, "âŒ PINs don't match! Start over with /start");
                  }

                  const encryptedPrivateKey = encryptPrivateKey(wallet.privateKey, confirmedPin);

                  await new User({
                    telegramId,
                    username: msg.from.username,
                    walletAddress: wallet.address,
                    encryptedPrivateKey,
                    securityCode: crypto.createHash("sha256").update(confirmedPin).digest("hex")
                  }).save();

                  bot.sendMessage(chatId, "âœ… Your wallet is secured and ready! \nUse /help for commands.", { parse_mode: "Markdown" });
                });
              });
            });
          } else {
            bot.sendMessage(chatId, "âŒ *Verification failed!* Use /start again.");
          }
        });
      } else if (callbackQuery.data.startsWith("seed_not_saved")) {
        bot.sendMessage(chatId, "âš ï¸ *Please save your seed phrase.*\nUse /start again when ready.");
      }
    });

  } catch (error) {
    console.error("Error creating wallet:", error);
    bot.sendMessage(chatId, "âŒ Error creating wallet. Please try again.");
  }
});

bot.onText(/\/resetwallet/, async (msg) => {
  const chatId = msg.chat.id;
  const telegramId = String(msg.from.id);

  const user = await User.findOne({ telegramId });
  if (!user) {
    return bot.sendMessage(chatId, "âŒ You need to register first.");
  }

  bot.sendMessage(chatId, "ðŸ” Enter your 5-digit PIN to reset:", {
    reply_markup: { force_reply: true }
  }).then((sentMessage) => {
    bot.onReplyToMessage(chatId, sentMessage.message_id, async (pinMsg) => {
      const pin = pinMsg.text.trim();
      const encryptedPin = crypto.createHash("sha256").update(pin).digest("hex");

      if (encryptedPin !== user.securityCode) {
        return bot.sendMessage(chatId, "âŒ Incorrect PIN!");
      }

      const newWallet = await createWallet();
      const words = newWallet.seedPhrase.split(' ');
      const randomIndexes = generateUniqueIndexes(words.length, 3);
      const challengeWords = randomIndexes.map(i => words[i]);

      const sentSeedMsg = await bot.sendMessage(chatId, `ðŸš¨ *Wallet Reset Complete!*  
ðŸ”¹ *New Address:* \`${newWallet.address}\`  
ðŸ”¹ *New Seed Phrase:* \`${newWallet.seedPhrase}\`  

â³ *This message will auto-delete in 15 minutes.*`, {
        parse_mode: "Markdown"
      });

      setTimeout(() => {
        bot.deleteMessage(chatId, sentSeedMsg.message_id).catch(() => { });
      }, 900000);

      bot.sendMessage(chatId, `ðŸ“Œ *Verify your seed phrase:*  

Enter these words:  
- #${randomIndexes[0] + 1}  
- #${randomIndexes[1] + 1}  
- #${randomIndexes[2] + 1}  

(Separated by spaces)`, { parse_mode: "Markdown" });

      bot.once("message", async (response) => {
        const userResponse = response.text.trim().split(" ");
        if (
          userResponse.length === 3 &&
          userResponse[0] === challengeWords[0] &&
          userResponse[1] === challengeWords[1] &&
          userResponse[2] === challengeWords[2]
        ) {
          const encryptedPrivateKey = encryptPrivateKey(newWallet.privateKey, pin);
          user.walletAddress = newWallet.address;
          user.encryptedPrivateKey = encryptedPrivateKey;
          await user.save();
          bot.sendMessage(chatId, "âœ… *Wallet reset complete!*");
        } else {
          bot.sendMessage(chatId, "âŒ *Verification failed!* Try /resetwallet again.");
        }
      });
    });
  });
});

bot.onText(/\/help/, (msg) => {
  const helpMessage = `
  ðŸ“˜ *Available Commands:*
  
  /start - Create a new wallet
  /help - Show help
  /balance - Check STX balance
  /tip <amount> <address> - Send STX
  /receive - Get wallet address
  /resetwallet - Reset wallet (requires PIN)
  `;
  bot.sendMessage(msg.chat.id, helpMessage, { parse_mode: "Markdown" });
});

bot.onText(/\/receive/, async (msg) => {
  const telegramId = String(msg.from.id);
  const user = await User.findOne({ telegramId });
  if (!user) {
    return bot.sendMessage(msg.chat.id, 'âŒ Register first with /start');
  }
  bot.sendMessage(msg.chat.id, `ðŸ”¹ *Your Address:* \`${user.walletAddress}\``, { parse_mode: "Markdown" });
});

function decryptPrivateKey(encryptedData, pin) {
  const combinedKey = crypto.createHash('sha256').update(pin + PRIVATE_KEY_SECRET).digest();
  const parts = encryptedData.split(':');
  const iv = Buffer.from(parts.shift(), 'hex');
  const encryptedText = Buffer.from(parts.join(':'), 'hex');
  const decipher = crypto.createDecipheriv('aes-256-cbc', combinedKey, iv);
  let decrypted = decipher.update(encryptedText);
  decrypted = Buffer.concat([decrypted, decipher.final()]);
  return decrypted.toString();
}

async function getNonce(address) {
  const accountUrl = `https://stacks-node-api.mainnet.stacks.co/v2/accounts/${address}`;
  const res = await fetch(accountUrl);
  if (!res.ok) throw new Error('Failed to fetch account data');
  const data = await res.json();
  return data.nonce;
}

bot.onText(/\/balance/, async (msg) => {
  const telegramId = String(msg.from.id);
  const user = await User.findOne({ telegramId });
  if (!user) {
    return bot.sendMessage(msg.chat.id, 'âŒ Register first with /start');
  }

  try {
    const url = `https://api.hiro.so/extended/v1/address/${user.walletAddress}/balances`;
    const response = await fetch(url);
    const accountData = await response.json();
    
    const stxBalance = parseInt(accountData.stx.balance) / 1e6;
    bot.sendMessage(
      msg.chat.id, 
      `ðŸ’° *STX Balance:* ${stxBalance} STX`, 
      { parse_mode: "Markdown", reply_to_message_id: msg.message_id }
    );
  } catch (error) {
    bot.sendMessage(msg.chat.id, 'âŒ Error fetching balance');
  }
});

bot.onText(/\/tip(?:\s+(@\S+))?\s+(\d+(\.\d+)?)/, async (msg, match) => {
  const groupChatId = msg.chat.id;
  const tipperTelegramId = String(msg.from.id);
  const optionalUsername = match[1];
  const tipAmount = parseFloat(match[2]);

  let timeout;

  try {
    if (isNaN(tipAmount) || tipAmount <= 0) {
      return bot.sendMessage(groupChatId, "âŒ Invalid amount");
    }

    const tipper = await User.findOne({ telegramId: tipperTelegramId });
    if (!tipper) {
      return bot.sendMessage(groupChatId, "âŒ Register first with /start");
    }

    let recipient;
    if (msg.reply_to_message) {
      const recipientTelegramId = String(msg.reply_to_message.from.id);
      recipient = await User.findOne({ telegramId: recipientTelegramId });
    } else if (optionalUsername) {
      const username = optionalUsername.replace('@', '');
      recipient = await User.findOne({ username });
    }

    if (!recipient) {
      return bot.sendMessage(groupChatId, "âŒ Recipient not found");
    }

    await bot.sendMessage(
      groupChatId,
      `@${msg.from.username}, check your DMs to confirm`,
      { reply_to_message_id: msg.message_id }
    );

    const dmMsg = await bot.sendMessage(
      tipperTelegramId,
      `Sending ${tipAmount} STX to ${recipient.username}\n` +
      "Enter your 5-digit PIN:",
      { reply_markup: { force_reply: true } }
    );

    const replyListener = async (replyMsg) => {
      try {
        if (!replyMsg.reply_to_message || replyMsg.reply_to_message.message_id !== dmMsg.message_id) {
          return;
        }

        bot.removeListener('message', replyListener);
        clearTimeout(timeout);

        const pin = replyMsg.text.trim();
        await bot.deleteMessage(tipperTelegramId, replyMsg.message_id).catch(() => { });

        let decryptedPrivateKey;
        try {
          decryptedPrivateKey = decryptPrivateKey(tipper.encryptedPrivateKey, pin);
        } catch (error) {
          return bot.sendMessage(tipperTelegramId, "âŒ Invalid PIN");
        }

        const nonce = await getNonce(tipper.walletAddress);
        const amountMicroSTX = BigInt(Math.round(tipAmount * 1e6));

        const txOptions = {
          recipient: recipient.walletAddress,
          amount: amountMicroSTX,
          senderKey: decryptedPrivateKey,
          network,
          fee: BigInt(5000),
          nonce: nonce,
          memo: "STX Tip",
          postConditionMode: PostConditionMode.Allow
        };

        const transaction = await makeSTXTokenTransfer(txOptions);
        const result = await broadcastTransaction({ transaction, network });
        const explorerLink = `https://explorer.hiro.so/txid/${result.txid}?chain=mainnet`;

        bot.sendMessage(
          tipperTelegramId,
          `âœ… ${tipAmount} STX sent!\n${explorerLink}`
        );

        bot.sendMessage(
          groupChatId,
          `âœ… ${tipAmount} STX tip from @${msg.from.username} to @${recipient.username}!`,
          { reply_to_message_id: msg.message_id }
        );

      } catch (error) {
        console.error("Tip error:", error);
        bot.sendMessage(tipperTelegramId, "âŒ Transaction failed");
      }
    };

    bot.on('message', replyListener);
    timeout = setTimeout(() => {
      bot.removeListener('message', replyListener);
      bot.sendMessage(tipperTelegramId, "âŒ› Timeout");
    }, 300000);

  } catch (error) {
    console.error("Tip command error:", error);
    bot.sendMessage(groupChatId, "âŒ Error processing tip");
  }
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});